import { supabase } from './supabase'
import type { User } from '@supabase/supabase-js'

// Transcription API using Supabase Storage and Database
export const transcriptionAPI = {
  // Upload audio file and create transcription record
  uploadAudio: async (file: File) => {
    try {
      // Get current user
      const { data: { user }, error: userError } = await supabase.auth.getUser()
      if (userError || !user) {
        throw new Error('User not authenticated')
      }

      // Generate unique filename
      const timestamp = Date.now()
      const fileExtension = file.name.split('.').pop()
      const fileName = `${user.id}/${timestamp}.${fileExtension}`

      // Upload file to Supabase Storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('audio-files')
        .upload(fileName, file, {
          cacheControl: '3600',
          upsert: false
        })

      if (uploadError) {
        console.error('Upload error:', uploadError)
        throw new Error(`Upload failed: ${uploadError.message}`)
      }

      // Get public URL for the uploaded file
      const { data: urlData } = supabase.storage
        .from('audio-files')
        .getPublicUrl(fileName)

      // Create transcription record in database
      const { data: transcriptionData, error: dbError } = await supabase
        .from('transcriptions')
        .insert({
          user_id: user.id,
          original_filename: file.name,
          file_type: file.type,
          file_size: file.size,
          original_file_url: urlData.publicUrl,
          status: 'UPLOADED'
        })
        .select()
        .single()

      if (dbError) {
        console.error('Database error:', dbError)
        // Try to clean up uploaded file
        await supabase.storage.from('audio-files').remove([fileName])
        throw new Error(`Failed to create transcription record: ${dbError.message}`)
      }

      return { 
        data: {
          transcriptionId: transcriptionData.id,
          transcription: transcriptionData
        }
      }
    } catch (error: any) {
      console.error('Upload audio error:', error)
      throw error
    }
  },

  // Start transcription process (mock for now)
  startTranscription: async (transcriptionId: string) => {
    try {
      // Update status to processing
      const { data, error } = await supabase
        .from('transcriptions')
        .update({ 
          status: 'PROCESSING_AUDIO',
          processing_started_at: new Date().toISOString()
        })
        .eq('id', transcriptionId)
        .select()
        .single()

      if (error) {
        throw new Error(`Failed to start transcription: ${error.message}`)
      }

      // Simulate transcription process (in a real app, this would trigger background processing)
      setTimeout(async () => {
        await supabase
          .from('transcriptions')
          .update({ 
            status: 'COMPLETED',
            processing_completed_at: new Date().toISOString(),
            transcript_text: 'This is a mock transcription. In a production environment, this would be generated by an AI transcription service.',
            duration_seconds: 120
          })
          .eq('id', transcriptionId)
      }, 5000) // Simulate 5 second processing time

      return data
    } catch (error: any) {
      console.error('Start transcription error:', error)
      throw error
    }
  },

  // Get user's transcriptions
  getTranscriptions: async (page = 1, limit = 20, status?: string) => {
    try {
      // Get current user
      const { data: { user }, error: userError } = await supabase.auth.getUser()
      if (userError || !user) {
        throw new Error('User not authenticated')
      }

      const offset = (page - 1) * limit
      
      let query = supabase
        .from('transcriptions')
        .select('*', { count: 'exact' })
        .eq('user_id', user.id)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1)

      if (status) {
        query = query.eq('status', status)
      }

      const { data, error, count } = await query

      if (error) {
        throw new Error(`Failed to fetch transcriptions: ${error.message}`)
      }

      return {
        data: {
          transcriptions: data || [],
          pagination: {
            page,
            limit,
            total: count || 0,
            totalPages: Math.ceil((count || 0) / limit),
            hasNext: offset + limit < (count || 0),
            hasPrev: page > 1
          }
        }
      }
    } catch (error: any) {
      console.error('Get transcriptions error:', error)
      throw error
    }
  },

  // Get transcription by ID (using direct database query)
  getTranscription: async (id: string) => {
    const { data, error } = await supabase
      .from('transcriptions')
      .select('*')
      .eq('id', id)
      .maybeSingle()

    if (error) throw error
    return data
  },

  // Delete transcription
  deleteTranscription: async (id: string) => {
    const { error } = await supabase
      .from('transcriptions')
      .delete()
      .eq('id', id)

    if (error) throw error
  },

  // Subscribe to transcription status changes
  subscribeToTranscription: (transcriptionId: string, callback: (payload: any) => void) => {
    return supabase
      .channel('transcription-updates')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'transcriptions',
          filter: `id=eq.${transcriptionId}`
        },
        callback
      )
      .subscribe()
  }
}

// Auth helpers
export const authAPI = {
  // Get current user
  getCurrentUser: async (): Promise<User | null> => {
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error) {
      console.error('Error getting user:', error)
      return null
    }
    return user
  },

  // Sign in with email and password
  signIn: async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    })

    if (error) throw error
    return data
  },

  // Sign up with email and password
  signUp: async (email: string, password: string) => {
    const { data, error } = await supabase.auth.signUp({
      email,
      password
    })

    if (error) throw error
    return data
  },

  // Sign out
  signOut: async () => {
    const { error } = await supabase.auth.signOut()
    if (error) throw error
  }
}
